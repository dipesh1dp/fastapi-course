from fastapi import FastAPI, Response, status, HTTPException, Depends, APIRouter
from sqlalchemy.orm import Session
from typing import List, Optional
from .. import models, schemas, oauth2
from ..database import get_db

router = APIRouter(
    prefix="/posts",  #/id   -> /posts/{id}
    tags=["Posts"]
)


@router.get("/", response_model=List[schemas.Post])
def get_posts(db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_current_user), 
              limit: int = 10, skip: int = 0, search: Optional[str] = ""): 
    """
    Get all posts.

    1. FastAPI injects the database session and the current authenticated user.
    2. Query all posts from the database.
    3. Return the list of posts.
    """
    ## Psycopg2 way (old)
    # cursor.execute("""SELECT * FROM posts""") 
    # posts = cursor.fetchall() 
    posts = db.query(models.Post).filter(models.Post.title.contains(search)).limit(limit).offset(skip).all()
    return posts


@router.get("/{id}", response_model=schemas.Post)
def get_post(id: int, db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_current_user)):
    """
    Get one post by id.

    1. Receive the post ID from the path.
    2. Query the database for a post with that ID.
    3. If no post is found → raise 404.
    4. If found → return the post.
    """ 
    ## Psycopg2 way (old)
    # cursor.execute("""SELECT * FROM posts WHERE id = %s""", (str(id),))
    # post = cursor.fetchone()
    post = db.query(models.Post).filter(models.Post.id == id).first()
    if not post:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND,
                            detail=f"Post with id: {id} was not found.")
    return post
 

@router.post("/", status_code=status.HTTP_201_CREATED, response_model=schemas.Post)
def create_posts(post: schemas.PostCreate, db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_current_user)):
    """
    Create a new post.

    1. Receive new post data from the request body.
    2. Create a Post model instance and attach the current user as the owner.
    3. Add the new post to the session.
    4. Commit the transaction to save it in the database.
    5. Refresh to get updated values (like autogenerated ID).
    6. Return the created post.
    """
    ## Psycopg2 way (old)
    # cursor.execute("""INSERT INTO posts (title, content, published) VALUES (%s, %s, %s) RETURNING * """, 
    #                (post.title, post.content, post.published))
    # new_post = cursor.fetchone()
    # conn.commit()
    new_post = models.Post(owner_id=current_user.id, **post.model_dump()) 
    db.add(new_post)
    db.commit()
    db.refresh(new_post)   # similar to RETURNING * in SQL
    return new_post 


@router.delete("/{id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_post(id: int, db: Session = Depends(get_db), current_user: int = Depends(oauth2.get_current_user)):
    """
    Delete a post by id. 

    1. Receive the post ID to delete.
    2. Query the database to find the post.
    3. If the post does not exist → raise 404.
    4. Check if the current user owns the post.
    5. If not owner → raise 403 (forbidden).
    6. Delete the post.
    7. Commit changes.
    8. Return empty response (204).
    """
    ## Psycopg2 way (old)
    # cursor.execute("""DELETE FROM posts WHERE id = %s RETURNING *""", (str(id)))
    # delelted_post = cursor.fetchone() 
    # conn.commit()
    post_query = db.query(models.Post).filter(models.Post.id == id)
    post = post_query.first()

    if post == None: 
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, 
                            detail=f"Post with id: {id} was not found.") 

    if post.owner_id != current_user.id: 
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, 
                            detail=f"Not authorized to perform requested action.")

    post_query.delete(synchronize_session=False) 
    db.commit()
    return Response(status_code=status.HTTP_204_NO_CONTENT)


@router.put("/{id}", response_model=schemas.Post)
def update_post(id: int, updated_post: schemas.PostCreate, db: Session = Depends(get_db), 
                current_user: int = Depends(oauth2.get_current_user)): 
    """
    Update a post by id. 

    1. Receive the post ID and updated data.
    2. Query the database for that post.
    3. If not found → raise 404.
    4. Check if the current user owns the post.
    5. If not owner → raise 403.
    6. Update the post with new data.
    7. Commit the changes.
    8. Return the updated post.
    """
    ## Psycopg2 way (old)
    # cursor.execute("""UPDATE posts SET title = %s, content = %s, published = %s WHERE id = %s RETURNING *""", 
    #                (post.title, post.content, post.published, str(id)))
    # updated_post = cursor.fetchone() 
    # conn.commit()
    print(f"Current User: {current_user.id}")
    post_query = db.query(models.Post).filter(models.Post.id == id)
    post = post_query.first()

    if post == None: 
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, 
                            detail=f"Post with id: {id} was not found.")
    
    if post.owner_id != current_user.id: 
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, 
                            detail=f"Not authorized to perform requested action.")

    post_query.update(updated_post.model_dump(), synchronize_session=False)
    db.commit()
    return post_query.first() 
